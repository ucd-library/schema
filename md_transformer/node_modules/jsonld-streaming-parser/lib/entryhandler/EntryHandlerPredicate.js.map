{"version":3,"file":"EntryHandlerPredicate.js","sourceRoot":"","sources":["EntryHandlerPredicate.ts"],"names":[],"mappings":"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","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport * as RDF from \"@rdfjs/types\";\nimport {ParsingContext} from \"../ParsingContext\";\nimport {Util} from \"../Util\";\nimport {IEntryHandler} from \"./IEntryHandler\";\n\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\nexport class EntryHandlerPredicate implements IEntryHandler<boolean> {\n\n  /**\n   * Handle the given predicate-object by either emitting it,\n   * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {Util} util A utility instance.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth The current depth.\n   * @param {Term} predicate The predicate.\n   * @param {Term} object The object.\n   * @param {boolean} reverse If the property is reversed.\n   * @return {Promise<void>} A promise resolving when handling is done.\n   */\n  public static async handlePredicateObject(parsingContext: ParsingContext, util: Util, keys: any[], depth: number,\n                                            predicate: RDF.Term, object: RDF.Term, reverse: boolean) {\n    const depthProperties: number = await util.getPropertiesDepth(keys, depth);\n    const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n    const depthPropertiesGraph: number = depth - depthOffsetGraph;\n\n    const subjects = parsingContext.idStack[depthProperties];\n    if (subjects) {\n      // Emit directly if the @id was already defined\n      for (const subject of subjects) {\n        // Check if we're in a @graph context\n        const atGraph = depthOffsetGraph >= 0;\n        if (atGraph) {\n          const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n          if (graphs) {\n            for (const graph of graphs) {\n              // Emit our quad if graph @id is known\n              if (reverse) {\n                util.validateReverseSubject(object);\n                parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n              } else {\n                parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n              }\n            }\n          } else {\n            // Buffer our triple if graph @id is not known yet.\n            if (reverse) {\n              util.validateReverseSubject(object);\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push(\n                {subject: object, predicate, object: subject});\n            } else {\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1)\n                .push({subject, predicate, object});\n            }\n          }\n        } else {\n          // Emit if no @graph was applicable\n          const graph = await util.getGraphContainerValue(keys, depthProperties);\n          if (reverse) {\n            util.validateReverseSubject(object);\n            parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n          } else {\n            parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n          }\n        }\n      }\n    } else {\n      // Buffer until our @id becomes known, or we go up the stack\n      if (reverse) {\n        util.validateReverseSubject(object);\n      }\n      parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({predicate, object, reverse});\n    }\n  }\n\n  public isPropertyHandler(): boolean {\n    return true;\n  }\n\n  public isStackProcessor(): boolean {\n    return true;\n  }\n\n  public async validate(parsingContext: ParsingContext, util: Util, keys: any[], depth: number, inProperty: boolean)\n    : Promise<boolean> {\n    const key = keys[depth];\n    if (key) {\n      const context = await parsingContext.getContext(keys);\n      if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {\n        // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n        if (Util.getContextValueType(context, key) === '@json') {\n          parsingContext.jsonLiteralStack[depth + 1] = true;\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public async test(parsingContext: ParsingContext, util: Util, key: any, keys: any[], depth: number)\n    : Promise<boolean> {\n    return keys[depth];\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number,\n                      testResult: boolean): Promise<any> {\n    const keyOriginal = keys[depth];\n    const context = await parsingContext.getContext(keys);\n\n    const predicate = await util.predicateToTerm(context, key);\n    if (predicate) {\n      const objects = await util.valueToTerm(context, key, value, depth, keys);\n      if (objects.length) {\n        for (let object of objects) {\n          const reverse = Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n\n          if (value) {\n            // Special case if our term was defined as an @list, but does not occur in an array,\n            // In that case we just emit it as an RDF list with a single element.\n            const listValueContainer = '@list' in Util.getContextValueContainer(context, key);\n            if (listValueContainer || value['@list']) {\n              if (((listValueContainer && !Array.isArray(value) && !value['@list'])\n                || (value['@list'] && !Array.isArray(value['@list'])))\n                && object !== util.rdfNil) {\n                const listPointer: RDF.Term = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil,\n                  util.getDefaultGraph()));\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object,\n                  util.getDefaultGraph()));\n                object = listPointer;\n              }\n\n              // Lists are not allowed in @reverse'd properties\n              if (reverse && !parsingContext.allowSubjectList) {\n                throw new ErrorCoded(`Found illegal list value in subject position at ${key}`,\n                  ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n              }\n            }\n          }\n\n          await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth,\n            predicate, object, reverse);\n        }\n      }\n    }\n  }\n\n}\n"]}