{"version":3,"file":"EntryHandlerKeywordId.js","sourceRoot":"","sources":["EntryHandlerKeywordId.ts"],"names":[],"mappings":";;;AAAA,iEAA8D;AAG9D,+DAA0D;AAE1D;;GAEG;AACH,MAAa,qBAAsB,SAAQ,yCAAmB;IAE5D;QACE,KAAK,CAAC,KAAK,CAAC,CAAC;IACf,CAAC;IAEM,gBAAgB;QACrB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,cAA8B,EAAE,IAAU,EAAE,GAAQ,EAAE,IAAW,EAAE,KAAU,EAAE,KAAa;QAE9G,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,sBAAsB,KAAK,GAAG,EAAE,mCAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC;SACxG;QAED,6CAA6C;QAC7C,gDAAgD;QAChD,MAAM,eAAe,GAAW,MAAM,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE3E,iDAAiD;QACjD,IAAI,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,KAAK,SAAS,EAAE;YACzD,IAAW,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAE,CAAC,QAAQ,EAAE;gBAC/D,sDAAsD;gBACtD,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CACrC,8DAA8D,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,EAChF,mCAAW,CAAC,0BAA0B,CAAC,CAAC,CAAC;aAC5C;iBAAM;gBACL,+DAA+D;gBAC/D,cAAc,CAAC,SAAS,CAAC,IAAI,kCAAU,CAAC,yBAAyB,cAAc;qBAC5E,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,KAAK,GAAG,EAAE,mCAAW,CAAC,kBAAkB,CAAC,CAAC,CAAC;aAC1F;SACF;QAED,4BAA4B;QAC5B,cAAc,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,IAAI,CAAC,cAAc,CAC1F,MAAM,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IACnD,CAAC;CAEF;AAvCD,sDAuCC","sourcesContent":["import {ERROR_CODES, ErrorCoded} from \"jsonld-context-parser\";\nimport {ParsingContext} from \"../../ParsingContext\";\nimport {Util} from \"../../Util\";\nimport {EntryHandlerKeyword} from \"./EntryHandlerKeyword\";\n\n/**\n * Handles @id entries.\n */\nexport class EntryHandlerKeywordId extends EntryHandlerKeyword {\n\n  constructor() {\n    super('@id');\n  }\n\n  public isStackProcessor(): boolean {\n    return false;\n  }\n\n  public async handle(parsingContext: ParsingContext, util: Util, key: any, keys: any[], value: any, depth: number)\n    : Promise<any> {\n    if (typeof value !== 'string') {\n      parsingContext.emitError(new ErrorCoded(`Found illegal @id '${value}'`, ERROR_CODES.INVALID_ID_VALUE));\n    }\n\n    // Determine the canonical place for this id.\n    // For example, @nest parents should be ignored.\n    const depthProperties: number = await util.getPropertiesDepth(keys, depth);\n\n    // Error if an @id for this node already existed.\n    if (parsingContext.idStack[depthProperties] !== undefined) {\n      if ((<any> parsingContext.idStack[depthProperties][0]).listHead) {\n        // Error if an @list was already defined for this node\n        parsingContext.emitError(new ErrorCoded(\n          `Found illegal neighbouring entries next to @list for key: '${keys[depth - 1]}'`,\n          ERROR_CODES.INVALID_SET_OR_LIST_OBJECT));\n      } else {\n        // Otherwise, the previous id was just because of an @id entry.\n        parsingContext.emitError(new ErrorCoded(`Found duplicate @ids '${parsingContext\n          .idStack[depthProperties][0].value}' and '${value}'`, ERROR_CODES.COLLIDING_KEYWORDS));\n      }\n    }\n\n    // Save our @id on the stack\n    parsingContext.idStack[depthProperties] = util.nullableTermToArray(await util.resourceToTerm(\n      await parsingContext.getContext(keys), value));\n  }\n\n}\n"]}